{"posts":[{"title":"Android","content":"Android之四大组件、六大布局、五大存储](https://www.cnblogs.com/tsingke/p/9007563.html) SDK＝放着你想要的软件功能的软件包 API＝SDK上唯一的接口 [TOC] 1.项目中的重要文件 AndroidManifest.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.himalaya&quot; &gt; &lt;application android:allowBackup=&quot;true&quot; //当allowBackup标志为true时，用户即可通过adb backup和adb restore来进行对应用数据的备份和恢复，这可/能会带来一定的安全风险。阿里聚安全建议将allowBackup属性值显示设置为false： android:icon=&quot;@mipmap/ic_launcher&quot; //icon：应用图标，一般都是放在以mipmap开头的文件夹内 android:label=&quot;@string/app_name&quot; //label：应用名称 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; //圆形应用图标 android:supportsRtl=&quot;true&quot; //（几乎不可能用到）是否支持从左往右视图 android:theme=&quot;@style/AppTheme&quot; &gt; //（不用管）自动生成基本主题 //每多一个activity（活动）和layout都会在这个项目配置文件自动添加以下内容对这个活动进行注册，这段内容对MainActivity这个活动进行注册，没有在AndroidManifest.xml注册的活动是不能使用的。 &lt;activity android:name=&quot;.MainActivity&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; //表示这是项目的主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; //表示这是App应用的启动活动，即点击APP第一个出现的 &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 安卓各版本对应版本号： MainActivity.java package com.example.himalaya; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; public class MainActivity extends AppCompatActivity { AppCompatActivity（AppCompatActivity是Activity的子类）：Activity 是其它Activity 的基类,包括appcompatactivity.AppCompatActivity默认带标题栏.从字面理解，App兼容Activity，意思是允许我们轻易地将API 21+的特性应用到之前的那些老的，不兼容的Activity上面。例如很容易地将Toolbar添加到Activity上 @Override protected void onCreate(Bundle savedInstanceState) { onCreate：本程序只有一个onCreate方法，这是一个活动被创建时必定要执行的方法 super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setContentView()方法给当前活动引入了一个叫activity_main的布局文件 } } build.gradle 1.最外层目录下的build.gradle文件 这些代码都是自动生成的，通常情况下不需要修改，除非你想要添加一些全局项目构建配置 // Top-level build file where you can add configuration options common to all sub-projects/modules. // 顶级构建文件，您可以在其中添加对所有子项目/模块通用的配置选项。 buildscript { repositories { google() jcenter() jcenter是一个代码托管仓库。声明jcenter()这行配置，就可以在项目中轻松引用任何jcenter上的开源项目。 } dependencies { classpath &quot;com.android.tools.build:gradle:4.10.1&quot; dependencies闭包中使用classpath声明了一个gradle插件。为什么要声明这个插件呢？因为Gradle并不是专门为构建Android项目而开发的, Java、 C+等很多 种项目都可以使用Gradle来构建。因此如果我们要想使用它来构建Android项目,则需要声明com.android.tools.build:gradle:4.2.0这个插件。其中,最后面的 部分是插件的版本号,我在写作本书时最新的插件版本是2.2.0。 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files ////注意：不要将您的应用程序依赖项放在此处；它们属于在各个模块的build.gradle文件中 } } allprojects { repositories { google() jcenter() } } task clean(type: Delete) { delete rootProject.buildDir } buildscript里的repositories与allprojects里的repositories 区别： buildscript里是gradle脚本执行所需依赖，分别是对应的maven库和插件 allprojects里是项目本身需要的依赖 Maven仓库 网络上主要有两种Maven仓库，分别是 mavenCentral() 和 jcenter() 1. Maven Central 是由sonatype.org维护的Maven仓库。 http://jcenter.bintray.com/ 2. jcenter是一个由 bintray.com维护的Maven仓库。 可以在这里看到整个仓库的内容。 https://oss.sonatype.org/content/repositories/releases/ maven中央仓库已经将内容浏览功能禁掉了，可在这个网站查询。 http://search.maven.org/ 但是 jcenter更好，是谷歌默认仓库。 JCenter() 与 mavenCenter()在完全不同的服务器上维护，由不同的人提供内容，两者之间毫无关系。在jcenter上有的可能 Maven Central 上没有，反之亦然。 Gradle支持从maven中央仓库和JCenter上获取构件。事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。 3.其他的网络公开仓库 Maven仓库列表 仓库名 简介 实际地址 使用地址 jcenter JFrog公司提供的仓库 http://jcenter.bintray.com https://maven.aliyun.com/repository/jcenter https://maven.aliyun.com/nexus/content/repositories/jcenter mavenLocal 本台电脑上的仓库 {USER_HOME}/.m2/repository C:/Users/liyujiang/.m2/repository (Windows) /home/liyujiang/.m2/repository (Linux) mavenCentral Sonatype公司提供的中央库 http://central.maven.org/maven2 https://maven.aliyun.com/repository/central https://maven.aliyun.com/nexus/content/repositories/central google Google公司提供的仓库 https://maven.google.com https://maven.aliyun.com/repository/google https://maven.aliyun.com/nexus/content/repositories/google https://dl.google.com/dl/android/maven2 jitpack JitPack提供的仓库 https://jitpack.io https://jitpack.io public jcenter和mavenCentral的聚合仓库 https://maven.aliyun.com/repository/public https://maven.aliyun.com/nexus/content/groups/public gradle-plugin Gradle插件仓库 https://plugins.gradle.org/m2 https://maven.aliyun.com/repository/gradle-plugin https://maven.aliyun.com/nexus/content/repositories/gradle-plugin 阿里云镜像源配置 在项目根目录下的build.gradle的allprojects.repositories闭包内的最前面添加阿里云的仓库地址： buildscript { repositories { jcenter() google() } } allprojects { repositories { maven {url 'https://maven.aliyun.com/repository/jcenter'} maven {url 'https://maven.aliyun.com/repository/central'} maven {url 'https://maven.aliyun.com/repository/google'} jcenter() mavenCentral() google() } } 4.其他私有仓库 如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。 例如： allprojects { repositories { jcenter() mavenCentral() maven { url 'https://maven.fabric.io/public' } maven { url &quot;https://jitpack.io&quot;} //引用本地仓库 mavenLocal() } } 你必须自己如下定义仓库的url。 repositories { maven { url 'https://maven.fabric.io/public' } } 然后在里面使用相同的方法获取一个library。 dependencies { compile 'com.crashlytics.sdk.android:crashlytics:2.2.4' } 因此，显而易见。将library上传到标准的服务器更好，如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。 但现在第三方库基本都是将library上传到自建服务器。 Android Studio早期版本使用的是mavenCentral()，后来切换到jcenter()了。 这是因为jcenter在性能和占存储大小方面比mavenCentral更优：balabala 2.app目录下的build.gradle文件 apply plugin android闭包{ ​ compileSdkVersion 29 ​ buildToolsVersion &quot;29.0.3&quot; ​ defaultConfig闭包{ ​ ...... ​ } ​ buildTypes闭包 { ​ release{ ​ ... ​ } ​ } } dependencies闭包{ ...... } apply plugin: 'com.android.application' 首先第一行应用了一个插件,一般有两种值可选: com.android.application表示这是一个应用程序模块,com. android. library表示这是一个库模块。应用程序模块和库模块的最大区别在于,一个是可以直接运行的,一个只 能作为代码库依附于别的应用程序模块来运行。 android { 接下来是一个大的android闭包,在这个闭包中我们可以配置项目构建的各种属性。 compileSdkVersion 29 其中,compilesdkVersion用于指定项目的编译版本,这里指定成24表示使用Android 7.0系统的SDK编译, buildToolsVersion &quot;29.0.3&quot; buildToolsVersion用于指定项目构建工具的版本,目前最新的版本就是24.0.2,如果有更新的版本时, Android Studio会进行提示。 defaultConfig { 在android闭包中又嵌套了一个defaultConfg闭包, defaultConfig闭包中可以对项目的更多细节进行配置。 applicationId &quot;com.example.himalaya&quot; 其中, applicationId用于指定项目的包名,前面我们在创建项目的时候其实已经指定过包名了,如果你想在 后面对其进行修改,那么就是在这里修改的。 改项目包名 minSdkVersion 21 minSdkVersion用于指定项目最低兼容的Android系统版本,这里指定成15表示最低兼容到Android 4.0系统 targetSdkVersion 29 （不太会用到）targetSdkVersion指定的值表示你在该目标版本上已经做过了充分的测试,系统将会为你的应用程序启用一些最 新的功能和特性。比如说Android 6.0系统中引入了运行时权限这个功能,如果你将targetSdkVersion指定成 23或者更高,那么系统就会为你的程序启用运行时权限功能,而如果你将targetSdkVersion指定成22,那么就说 明你的程序最高只在Android 5.1系统上做过充分的测试, Android 6.0系统中引入的新功能自然就不会启用了。 versionCode 1 剩下的两个属性都比较简单, versionCode用于指定项目的版本号, versionName &quot;1.0&quot; versionName用于指定项目的版本名,这两个属性在生成安装文件的时候非常重要,我们在后面都会学到。 testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes闭包中用于指定生成安装文件的相关配置,通常只会有两个子闭包,一个是debug,一个是release, debug闭包用于指定生成测试版安装文件的配置, release闭包用于指定生成正式版安装文件的配置。另外debug闭 包是可以忽略不写的,因此我们看到上面的代码中就只有一个release闭包。 buildTypes { release { minifyEnabled false minifyEnabled用于指定是否对项目的代码进行混淆, true表示混淆, false表示不混淆。 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } proguardFiles用于指定混淆时使用的规则文件,这里指定了两个文件,第一个proguard-android.txt是在 Android SDK目录下的,里面是所有项目通用的混淆规则,第二个proguard-rules.pro是在当前项目的根目录下的, 里面可以编写当前项目特有的混淆规则。需要注意的是,通过Android Studio直接运行项目生成的都是测试版安装文 件,关于如何生成正式版安装文件我们将会在第15章中学习。 } } dependencies { implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) 第一行的compile fileTree就是一个本地依赖声明,它表示将libs目录下所 有.jar后缀的文件都添加到项目的构建路径当中。 implementation 'androidx.appcompat:appcompat:1.2.0' 而第二行的compile则是远程依赖声明,com. android. support : appcompat-v7: 24.2.1就是一个标准的远程依赖库格式,其中com. android. support是域名部分,用于和其他公司的库做区分; appcompat-v7是组名称,用于和 同一个公司中不同的库做区分; 24.2.1是版本号,用于和同一个库不同的版本做区 分。加上这句声明后, Gradle在构建项目时会首先检查一下本地是否已经有这个库 的缓存,如果没有的话则会去自动联网下载,然后再添加到项目的构建路径当中。 implementation 'androidx.constraintlayout:constraintlayout:2.0.1' testImplementation 'junit:junit:4.12' testCompile是用于声明测试用例库的,这个我们暂时用不到,先忽略它就可以了。 androidTestImplementation 'androidx.test.ext:junit:1.1.2' androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' } dependencies闭包。这个闭包的功能非常强大,它可以指定当前项目所有的依赖关系。通常Android Studio项目一共 有3种依赖方式:本地依赖、库依赖和远程依赖。本地依赖可以对本地的Jar包或目录添加依赖关系,库依赖可以对项目中 的库模块添加依赖关系,远程依赖则可以对jcenter库上的开源项目添加依赖关系。 R文件 存储的都是数值型的东西 2.日志工具（Logcat） Android日志工具类Log(android.util.Log) 五个方法打印日志 Log.v() berbose Log.d() debug Log.i() info Log.w() warn Log.e() error 用于取代 System.out.println(); 快速打印日志：logd+快捷键TAB补全 为了避免总是写TAG，可以在onCreate()方法外面 打上logt+快捷键TAB补全，就会生成 private static final String TAG = &quot;MainActivity&quot;; //MainActivity 为当前类名 过滤器 3.Activity 1.基础 项目中的任何活动都应该重写 Activity 的 onCreate()方法。 所有的活动都要在 AndroidManifest.xml文件 中进行注册才能生效。 ​ 配置主活动的方法：在 标签的内部加入 标签，并在这个标签内加两句声明。 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; 表示这是项目的主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; 表示这是App应用的启动活动，即点击APP第一个出现的 &lt;/intent-filter&gt; android:label=&quot;笑死我了&quot; 指定活动中标题栏的内容，给主活动添加label标签的同时，应用程序名字也会变 举例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity2&quot; /&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;笑死我了&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 2.设置监听器（点击按钮实现Toast通知） 通过调用 setOnClickListener() 方法为按钮注册一个监听器， 点击按钮就会执行监听器中的 onClick() 方法 匿名内部类理解问题很重要 1.（推荐） //Toast使用 Button bt1=findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this, &quot;你居然点这个按钮，宝贝！&quot;, Toast.LENGTH_SHORT).show(); //Toast通知——第三个参数有LENGTH_SHORT或LONG } }); but = findViewById(R.id.but); //与布局文件的相关组建关联 but.setOnClickListener(new click()); //注册监听接口 } class click implements View.OnClickListener { //定义一个类实现监听的接口 public void onClick(View v) { Intent intent = new Intent(MainActivity.this, MainActivity2.class); // 创建好之后就可以通过它启动新的Activity startActivity(intent); } } 设置一个按钮的不同点击触发事件 my_day_model = (RelativeLayout) v.findViewById(R.id.my_day_model); my_day_pic = (ImageView) v.findViewById(R.id.my_day_pic); my_day_text = (TextView) v.findViewById(R.id.my_day_text); my_day_model.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (flag == 0){ //点击一次的出发事件 my_day_pic.setImageResource(R.drawable.pic_my_day_pic2); my_day_text.setText(R.string.my_day_text2); flag = 1; }else { //点击两次的触发事件 my_day_pic.setImageResource(R.drawable.pic_my_day_pic1); my_day_text.setText(R.string.my_day_text1); flag = 0; } } }); 3.Menu 1.先在res文件夹新建一个menu文件夹，再在下面新建一个MenuResourceFile文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot;/&gt; &lt;/menu&gt; 2.重写 onCreateOptionsMenu() 方法， 重写方法使用快捷键 CTRL+O //Menu使用 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main,menu); return super.onCreateOptionsMenu(menu); } 通过getMenuInflater()方法能够得到MenuInflater对象,再调用它的inflate()方法就可以给当前活动创建菜单了。inflate ()方法接收两个参数,第一个参数用于指定我们通过哪一个资源文件来创建菜单,这里当然传入R. menu.main。第二个参数用于指定我们的菜单项将添加到哪一个Menu对象当中,这里直接使用onCreateOptionsMenu ()方法中传入的menu参数。然后给这个方法返回true,表示允许创建的菜单显示出来,如果返回了false,创建的菜单将无法显示。 3.定义菜单响应事件，重写onOptionsItemSelected()方法 在onOptionsItemselected()方法中,通过调用item.getItemld()来判断我们点击的是哪一个菜单项,然后给每个菜单项加入自己的逻辑处理,这里我们就活学活用,弹出一个刚刚学会的Toast. @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()){ case R.id.add_item: Toast.makeText(MainActivity.this, &quot;你点了Add呢，好棒哦！&quot;, Toast.LENGTH_LONG).show(); break; case R.id.remove_item: Toast.makeText(MainActivity.this, &quot;你点了Remove！&quot;, Toast.LENGTH_LONG).show(); break; default: } return super.onOptionsItemSelected(item); } 4.销毁一个活动 finish() 5.使用Intent（意图）在活动之间穿梭 1.显式Intent Intent intent =new Intent(MainActivity.this,MainActivity2.class); startActivity(intent); 2.隐式Intent 一般 打开内置浏览器打开网页 public void onClick(View v) { Intent intent =new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); startActivity(intent); } 调用系统拨号界面 Intent.ACTION_VIEW Android 系统内置动作 6.活动之间传递数据 7.活动的生命周期 返回栈 1.活动状态 运行状态——位于返回栈的栈顶 暂停状态——可见 停止状态——完全不可见 销毁状态——从返回栈中移除 2.活动的生命周期 activity类中定义的7个回调方法 onCreate() 一个活动会在其中完成各种初始化操作。例加载布局、绑定事件 ​ onStart() 活动由不可见变为可见的时候调用 ​ onResume() 准备好进行交互。此时活动位于栈顶，处于运行状态。 ​ onPause() 暂停状态，可见 ​ onStop() 停止状态，不可见 onDestroy() 完成释放内存的操作 onRestart() stop---&gt;start 之前运行 3.活动被回收了怎么办 onSaveInstanceState() @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState !=null){ String tempData = savedInstanceState.getString(&quot;data_key&quot;); Log.d(TAG,tempData); } } Intent 结合 Bundle 一起用于传递数据 数据保存在Bundle对象，再将Bundle对象保存在Intent里 8.活动的启动模式 standard singleTop singleTask singleInstance 在 AndroidManifest.xml 中给 标签制定 android:launchMode 属性来选择启动模式。 standard 活动默认启动模式 singleTop singleTask 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例 singleInstance 如果启动的Activity不存在就创建一个Activity同时创建一个栈，如果存在就将指定的Activity存在的栈移动到栈顶（表示这个Activity只能存在于一个独立的任务栈中,同应用的其它Activity与其无关） 有点复杂，还没有看，回过头需要再看 9.活动最佳实践 1.知晓当前是在哪一个活动 2.随时随地退出程序 退出所有活动再杀掉当前程序进程： android .os.Process.killProcess(android.os.Process.myPid()); 3.启动另一个活动的最佳写法 公司合作更方便，以后用到再看 4.UI （ViewGroup代表LinearLayout等各种布局控件，View代表TestView等各种控件） ActionBar和ToolBar 每个活动最顶部的那个标题栏其实就是 Actionbar，之前我们编写的所有程序里一直都有 Actionbar的身影 ​ Actionbar由于其设计的原因，被限定只能位于活动的顶部，从而不能实现一些 Material Design的效果，因此官方现在已经不再建议使用 Actionbar了。那么本书中我也就不准备再介绍 Action Bar I的用法了，而是直接讲解现在更加推荐使用的 Toolbar 推荐使用ToolBar，隐藏ActionBar 详细查阅请看 第一行代码P410 ImageView 图片导入时名字开头必须改为英文 ScaleType属性 ImageView可以设置src和background属性，只有设置了“前景图”src,设置的scalType属性才会生效。 scaleType默认值为：centerInside android:scaleType=“center_Inside” ​ fit开头的基本都是保持高度占满 FIT_CENTER 把原图按照比例放大缩小到ImageView的 宽度，显示在ImageView的center（中部/居中显示）。 FIT_START 把原图按照比例放大缩小到ImageView的宽度，显示在ImageView的start（前部/上部）。 FIT_END 把原图按照比例放大缩小到ImageView的宽度，显示在ImageVIew的end（后部/尾部/底部）。 .FIT_XY 把图片按照指定的大小在ImageView中显示，拉伸显示图片，不保持原比例，填满ImageView.——有用 CENTER 保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size时，多出来的部分被截掉. CENTER_INSIDE 以原图正常显示为目的，如果原图大小大于ImageView的size，就按比例缩小原图的宽高，缩小直到最长边填满，居中显示在ImageView中。如果原图size小于ImageView的size，则不做处理居中显示图片。——有空出来 . ？CENTER_CROP 会***拉伸图片***以原图填满ImageView为目的，如果原图size大于ImageView的size，则与center_inside一样，按比例缩小，缩小直到宽或高填满，居中显示在ImageView上。如果原图size小于ImageView的size，则按比例拉升原图的宽和高，填充ImageView居中显示。——有用 **8.**MATRIX 不改变原图的大小，从ImageView的左上角开始绘制，超出部分做剪切处理。如果显示不下会改变显示方向。——没用 修改EditText下划线颜色 / 隐藏标题栏 导入SVG变成XML的矢量图片 使用原因： 如果使用.png；.jpg。。。这样的图片，一般在资源文件中，都需要准备不同分辨率的图。 这样既让apk臃肿，也增加了工作量。 于是，矢量图标出现了。只需一张图，矢量图标会自适应各种分辨率，而且节约了空间，还减小了工作量。这就是你选择它的原因。 方法 一：https://blog.csdn.net/stoneWang_L/article/details/81516017 二：使用Android Studio插件，SVG2VectorDrawable https://www.jianshu.com/p/5c171cdccd61?utm_campaign 带清除功能的编辑框（ClearEditText） 通过新建一个ClearEditText类继承EditText类实现 简单按钮渐变动画 验证码实现 Android EditText 禁止换行 在EditText的xml文件中通过配置android:singleLine=&quot;true&quot;把虚拟键盘上的enter键禁止掉，不会显示。 始终以竖屏显示 当在AndroidManifest.xml文件中定义了android:screenOrientation=&quot;portrait&quot;， 就表示当我们切换横竖屏的时候，屏幕的内容始终以竖屏显示，而不会根据屏幕的方向来显示内容 &lt;activity android:name=&quot;.CreateActivity&quot; android:screenOrientation=&quot;portrait&quot;&gt; 四大图片缓存（Imageloader,Picasso,Glide,Fresco）原理、特性对比 RecyclerView（Listview的增强版）——太麻烦了不用 我觉得最好的理解文章——https://www.sunofbeach.net/a/1302501683145740288 1. 是什么 Adapter是连接后端数据和前端显示的适配器接口，是数据和UI（View）之间一个重要的纽带。在常见的View(ListView,GridView)等地方都需要用到Adapter。如下图直观的表达了Data、Adapter、View三者的关系： adapter可以把获得的数据装配到View上。 控制其显示的方式，请通过布局管理器LayoutManager 控制Item间的间隔（可绘制），请通过ItemDecoration 控制Item增删的动画，请通过ItemAnimator 控制点击、长按事件（暂不支持） //设置布局管理器 recyclerview.setLayoutManager(new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL)); //设置Item增加、移除动画 recyclerview.setItemAnimator(new DefaultItemAnimator()); /* //添加分割线 recyclerview.addItemDecoration(new DividerItemDecoration(getActivity(), DividerItemDecoration.HORIZONTAL_LIST));*/ // recyclerview.addItemDecoration();//设置分割线 // 设置adapter recyclerview.setAdapter(mAdapter); Java泛型理解 2. 适配器Adapter和 ViewHolder Adapter 的理解 Adapter ：适配器，因为 ListView 是一个 View ，不能添加子项，因此在呈现数据的时候就需要某种工具将数据呈现在 ListView 上，而 Adapter 就能充当此角色。常用的 Adapter：ArrayAdapter、BaseAdapter等。 ViewHolder 的理解 要想使用 ListView 就需要编写一个 Adapter 将数据适配到 ListView上，而为了节省资源提高运行效率，一般自定义类 ViewHolder 来减少 findViewById() 的使用以及避免过多地 inflate(填充) view，从而实现目标。ViewHolder的出现就是为了保存View引用的容器类，减少重复findViewById次数。相当于一个辅助工具 Adapter的定义 继承 BaseAdapter (可在继承的时候指定泛型，扩展使用); 重写四个基本方法： getCount()：获取数据的总的数量，返回 int 类型的结果； getItem(int position) ：获取指定位置的数据，返回该数据； getItemId(int position)：获取指定位置数据的id，返回该数据的id，一般以数据所在的位置作为它的id； getView(int position,View convertView,ViewGroup parent)：关键方法，用于确定列表项 创建 ViewHolder （包含列表项的控件。） 代码展示（部分） public class RecyclerviewAdapter extends RecyclerView.Adapter&lt;RecyclerviewAdapter.ViewHolder&gt; { private Context context; private List&lt;String&gt; data; public RecyclerviewAdapter(Context context,List&lt;String&gt; data){ this.context = context; this.data = data; } @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(context).inflate(R.layout.item_recyclerview,parent,false); return new ViewHolder(view); } @Override public void onBindViewHolder(@NonNull ViewHolder holder, final int position) { holder.name.setText(data.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(&quot;这里是点击每一行item的响应事件&quot;,&quot;&quot;+position+item); } }); } @Override public int getItemCount() { return data.size(); } public class ViewHolder extends RecyclerView.ViewHolder{ private TextView name; public ViewHolder(View itemView) { super(itemView); name = itemView.findViewById(R.id.name); } } } 适配器模式——Android列表视图控件设计方式 Android源码中的设计模式 —— RecyclerView RecyclerView 中的设计模式——通俗易懂 RecyclerView提供自己的adapter：RecyclerView.Adapter，该适配器已经集成了ViewHolder类，只需要实现里面的onCreateViewHolder、onBindViewHolder抽象方法，具体使用如下： getItemCount()：获取数据的总的数量，返回 int 类型的结果； package com.lzy.host.perfect.adapter; import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import com.lzy.host.perfect.R; import java.util.List; /** * RecyclerViewAdapter * * @author linzhiyong * @time 2017年2月8日15:17:41 * @email wflinzhiyong@163.com * @desc */ public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt; { private Context context; private List&lt;Integer&gt; data; public RecyclerViewAdapter(Context context, List&lt;Integer&gt; data) { this.context = context; this.data = data; } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context).inflate(R.layout.item_recyclerview, parent, false)); return holder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.imageView.setImageResource(this.data.get(position)); if (position % 2 == 0) { holder.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 300)); } else { holder.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 400)); } } @Override public int getItemCount() { return this.data.size(); } class MyViewHolder extends RecyclerView.ViewHolder { private ImageView imageView; public MyViewHolder(View itemView) { super(itemView); this.imageView = (ImageView) itemView.findViewById(R.id.imageView1); } } } 3. 使用方法 1.activity private MyRecyclerAdapter adapter; //声明自定义类 MyRecyclerAdapter 的变量 adapter @BindView(R.id.recyclerview) RecyclerView recyclerview; //声明 RecyclerView类 的变量 recyclerview，并用牛油刀绑定布局文件上的id @Override protected void onCreate(Bundle savedInstanceState) { ...... //设置布局管理器 recyclerview.setLayoutManager(new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL)); //设置2列交错式网格布局 //设置Item增加、移除动画 recyclerview.setItemAnimator(new DefaultItemAnimator()); /* //设置recyclerview的内边距 //recyclerview.setPadding(8,8,8,8); */ /* //添加Android自带的分割线 recyclerview.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)); //垂直分割线 recyclerview.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.HORIZONTAL)); //水平分割线 */ //设置适配器 adapter = new MyRecyclerAdapter(this, createData()); //利用自定义类 MyRecyclerAdapter 构造一个新对象 传入 adapter recyclerview.setAdapter(adapter); 下面这个对应的是上面输入的参数createData()，这个根据自己写，不一样的 public class HomeActivity extends AppCompatActivity { protected void onCreate(Bundle savedInstanceState) { ... } private List&lt;Integer&gt; createData() { List&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { data.add(R.mipmap.ic_launcher); } else { data.add(R.mipmap.ic_launcher_round); } } return data; } } 2.MyRecyclerAdapter 自定义类 MyRecyclerAdapter ，即我们造的 适配器adapter package com.example.myapplication; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import androidx.recyclerview.widget.RecyclerView; import java.util.List; /** * RecyclerViewAdapter */ //MyRecyclerAdapter继承自RecyclerView.Adapter （因为RecyclerView自带 Adapter 和 ViewHolder），？并且泛型为MyRecyclerAdapter.MyViewHolder public class MyRecyclerAdapter extends RecyclerView.Adapter&lt;MyRecyclerAdapter.MyViewHolder&gt; { private Context context; //context、data 由下面的构造函数中的参数获取 private List&lt;Integer&gt; data; //MyRecyclerAdapter 的构造方法，参数为Context类型（使用时输入this）和整型列表List public MyRecyclerAdapter(Context context, List&lt;Integer&gt; data) { this.context = context; this.data = data; } @Override //重载方法onCreateViewHolder，返回类型为本类MyRecyclerAdapter的自构内部类 MyViewHolder。参数为 ViewGroup类型 和 int类型 //用于生成一个 已经填充的 MyViewHolder public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context).inflate(R.layout.item_recyclerview, parent, false)); return holder; //返回了一个填充 R.layout.item_recyclerview 的 名为holder 的 MyViewHolder 对象 } //重载方法onBindViewHolder，无返回值。参数为 MyViewHolder类型 和 int类型 //用于将 源数据 传入 填充了 item_recyclerview 的 MyViewHolder 里————即为绑定bind 。同时设置显示高度 @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.imageView.setImageResource(this.data.get(position)); //找到data中位置为position的数据（资源ID）传入holder的imageview的资源id来源设置 if (position % 2 == 0) { //位置参数position为偶数则设置高度为300 holder.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 300)); } else { //位置参数position为奇数则设置高度为400 holder.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 400)); } } //用于获取数据大小长度 @Override public int getItemCount() { return this.data.size(); } //内部自定义类 MyViewHolder ，继承自 RecyclerView.ViewHolder。（好像这个类也可以分离出去单独成为一个文件我记得？） class MyViewHolder extends RecyclerView.ViewHolder { private ImageView imageView; //声明ImageView类型的 变量名imageView public MyViewHolder(View itemView) { super(itemView); //实现父类的构造方法，再将imageView1控件传入imageView this.imageView = (ImageView) itemView.findViewById(R.id.imageView1); } } } 4.分割线 1.自带分割线 //添加Android自带的分割线 recyclerview.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)); //垂直分割线 recyclerview.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.HORIZONTAL)); //水平分割线 交错式网格布局用分割线不好看 2.自定义分割线（以下还未看） 有时候默认的浅灰色的分割线并不能满足我们的要求，这时我们就需要自己“写”一条分割线了，那应该怎么写呢？打开DividerItemDecoration看看它的源码，有这么一个函数： public void setDrawable(@NonNull Drawable drawable) { if (drawable == null) { throw new IllegalArgumentException(&quot;Drawable cannot be null.&quot;); } mDivider = drawable; }123456 我们只需要调用这个方法，然后传入一个Drawable函数对象就可以了。现在可以用shape来编写一个分割线样式: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:centerColor=&quot;#ff00ff00&quot; //绿色 android:endColor=&quot;#ff0000ff&quot; //蓝色 android:startColor=&quot;#ffff0000&quot; //红色 android:type=&quot;linear&quot; /&gt; &lt;size android:height=&quot;3dp&quot; /&gt; &lt;/shape&gt;123456789101112 我这里弄的是一条骚气的渐变色分割线。然后添加分割线的代码改为如下： //添加自定义分割线 DividerItemDecoration divider = new DividerItemDecoration(this,DividerItemDecoration.VERTICAL); divider.setDrawable(ContextCompat.getDrawable(this,R.drawable.custom_divider)); recyclerView.addItemDecoration(divider);1234 跑起来之后，就可以看到一条多彩的分割线了： 这样一来使用范围就广很多了，比如item之间需要一定的间隔，那么我们就可以加一条透明的分割线。 5.图片自适应高度（不推荐使用，还是固定高度靠谱） 1.设置item 布局宽高 2.onBindViewHolder //获取item宽度，计算图片等比例缩放后的高度，为 lmagevlew设置参数 Linearlayout. Layoutparams layoutparams=(Linearlayout. Layoutparams )holder. imageview getlayoutparams() float itemwidth =(Screenutils getscreenwidth(holder. itemview getcontext()-8*3)/2 layoutparams. width =(int) itemwidth float scale -(itemwidth+0f)/book width; layoutparams. height=(int)(book. height&quot;scale); holder. imageview. setlayoutparams(layoutparams); 6.点击触发事件 1.activity //以下为设置监听 adapter.setOnClickListener(new MyRecyclerAdapter.OnItemClickListener() { @Override public void ItemClickListener(View view, int postion) { Toast.makeText(HomeActivity.this,&quot;点击了：&quot;+postion,Toast.LENGTH_SHORT).show(); } @Override public void ItemLongClickListener(View view, int postion) { //长按删除 lists.remove(postion); adapter.notifyItemRemoved(postion); } }); 2.MyRecyclerAdapter @Override public void onBindViewHolder(MyViewHolder holder, int position) { ...... //以下为设置监听 if(mListener!=null){//如果设置了监听那么它就不为空，然后回调相应的方法 holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int pos = holder.getLayoutPosition();//得到当前点击item的位置pos mListener.ItemClickListener(holder.itemView,pos);//把事件交给我们实现的接口那里处理 } }); holder.itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { int pos = holder.getLayoutPosition();//得到当前点击item的位置pos mListener.ItemLongClickListener(holder.itemView,pos);//把事件交给我们实现的接口那里处理 return true; } }); } } *****7.BaseRecyclerViewAdapterHelper 开源库 1.使用 BRVAH例子测试项目（用来理解参考）：C:\\Users\\Sage\\AndroidStudioProjects\\BRVAHTest 1.框架引入 先在 build.gradle(Project:XXXX) 的 repositories 添加: allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 然后在 build.gradle(Module:app) 的 dependencies 添加: dependencies { implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4' } 更新说明：https://github.com/CymChad/BaseRecyclerViewAdapterHelper/releases 2.使用Adapter 第一步：在布局文件中引入RecyclerView 大视图——容纳所有小东西 *activity_main.xml* &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/RelativeLayout&gt; 第二步：编写条目布局文件R.layout.item_rv——每一个小块，并不一定是具体的实例，可以相当于一个模板，要显示什么类型，就添加相应控件 *item_rv.xml* &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;5dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_img&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;80dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_toRightOf=&quot;@+id/iv_img&quot; android:text=&quot;我是标题&quot; android:textColor=&quot;#f00&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@+id/tv_title&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/iv_img&quot; android:text=&quot;我是描述&quot; /&gt; &lt;/RelativeLayout&gt; 第三步：编写自定义数据实体类型（如果仅仅是显示普通的文字、图片不用定义这个类） ——数据实体类与条目布局文件对应，都是用来作为模板，动态显示。（数据实体包括多种属性，用来显示多种类型数据的） *Model.java* public class Model { private String title; private String content; private String imgUrl; //生成set、get方法 ...... } 第四步：编写适配器 *MyAdapter.java* public class MyAdapter extends BaseQuickAdapter&lt;Model, BaseViewHolder&gt; { //左边参数@LayoutRes int layoutResId用于传入小条目布局文件的int型资源ID（即为R.layout.item_rv）， //右边传入的是 数据实体类型 的链表，用于存每一个条目的数据。——测试传入的都是模拟数据，实际上都是网络上获取的数据。 public MyAdapter(@LayoutRes int layoutResId, @Nullable List&lt;Model&gt; data) { super(layoutResId, data); }. @Override //左边参数默认不用改，右边参数中的 Model 是自定义实体数据类型，也可以填int（只显示数字）、String（只显示文字），自定义数据类型才能显示多种东西 protected void convert(BaseViewHolder helper, Model item) { //可链式调用赋值——相当于替换，将左边的替换成右边的。每一句话代表设置布局文件中控件的属性 helper.setText(R.id.tv_title, item.getTitle()) .setText(R.id.tv_content, item.getContent()) .setImageResource(R.id.iv_img, R.mipmap.ic_launcher);//将R.id.iv_img控件的ImageResource改为R.mipmap.ic_launcher //获取当前条目position //int position = helper.getLayoutPosition(); } } 最后一步：在Activity中使用该适配器 *MainActivity.java* public class MainActivity extends AppCompatActivity { private RecyclerView recyclerView; private List&lt;Model&gt; datas; private MyAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); //模拟的数据（实际开发中一般是从网络获取的） datas = new ArrayList&lt;&gt;(); Model model; for (int i = 0; i &lt; 15; i++) { model = new Model(); model.setTitle(&quot;我是第&quot; + i + &quot;条标题&quot;); model.setContent(&quot;第&quot; + i + &quot;条内容&quot;); datas.add(model); } //创建布局管理 LinearLayoutManager layoutManager = new LinearLayoutManager(this); layoutManager.setOrientation(LinearLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); //创建适配器 adapter = new MyAdapter(R.layout.item_rv, datas); //给RecyclerView设置适配器 recyclerView.setAdapter(adapter); } } OK，运行，得到的效果就是上述的效果。 2.点击事件 1 条目事件 Item的点击事件 //条目点击事件 adapter.setOnItemClickListener(new BaseQuickAdapter.OnItemClickListener() { @Override public void onItemClick(BaseQuickAdapter adapter, View view, int position) { Toast.makeText(MainActivity.this, &quot;点击了第&quot; + (position + 1) + &quot;条条目&quot;, Toast.LENGTH_SHORT).show(); } }); Item的长按事件 //条目长按事件 adapter.setOnItemLongClickListener(new BaseQuickAdapter.OnItemLongClickListener() { @Override public boolean onItemLongClick(BaseQuickAdapter adapter, View view, int position) { adapter.remove(position); //长按删除 Toast.makeText(MainActivity.this, &quot;长按了第&quot; + (position + 1) + &quot;条条目&quot;, Toast.LENGTH_SHORT).show(); return false; } }); Item的长按删除 adapter.remove(position); //长按删除 注意事项 在嵌套recycleView的情况下需要使用你使用 adapter. setOnItemClickListener 来设置点击事件,如果使用recycleView.addOnItemTouchListener会累计添加的。 Glide 一、简介 Glide，一个被google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方app。 使用简单 可配置度高，自适应程度高 支持常见图片格式 Jpg png gif webp 支持多种数据源 网络、本地、资源、Assets 等 高效缓存策略 支持Memory和Disk图片缓存 默认Bitmap格式采用RGB_565内存使用至少减少一半 生命周期集成 根据Activity/Fragment生命周期自动管理请求 高效处理Bitmap 使用Bitmap Pool使Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力. 二、使用 1.导入库（添加依赖） Project目录下的build.gradle文件 repositories { google() //or maven { url 'https://maven.google.com' } jcenter() } APP目录下的build.gradle文件 dependencies { /*Glide加载库*/ implementation 'com.github.bumptech.glide:glide:4.11.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0' } /** * 在此方法中设置item数据 */ @Override protected void convert(@NotNull BaseViewHolder helper, @NotNull Integer item) { //Glide加载应用资源图片 Glide.with(getContext()) .load(item) .into((ImageView) helper.getView(imageView1)); //是将资源加载到holder上的imageView1中，而不是直接加载到imageView1中 // helper.setImageResource(imageView1,item); //BRVAH自带设置图片 } 2.圆角图片显示——实测嵌套在recyclerview内没有用 public class MainActivity extends AppCompatActivity { ImageView circle, round1, round2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { circle = findViewById(R.id.circle); round1 = findViewById(R.id.round1); round2 = findViewById(R.id.round2); Glide.with(this) .load(&quot;http://img5.duitang.com/uploads/item/201506/07/20150607110911_kY5cP.jpeg&quot;) .apply(RequestOptions.bitmapTransform(new CircleCrop())) .into(circle); Glide.with(this) .load(&quot;http://img.jiuzheng.com/memberlogo/s/57/0a/570af0f48f1e0327178b468d.jpg&quot;) .apply(RequestOptions.bitmapTransform(new RoundedCorners(20)))//圆角半径 .into(round1); Glide.with(this) .load(&quot;http://img.jiuzheng.com/memberlogo/s/57/0a/570af0f48f1e0327178b468d.jpg&quot;) .apply(RequestOptions.bitmapTransform(new RoundedCorners(60)))//圆角半径 .into(round2); } } PhotoView的使用 第三方库：PhotoView旨在帮助生成一个易于使用的缩放Android ImageView的实现。 这是一个图片查看库，实现图片浏览功能，支持pinch（捏合）手势或者点击放大缩小。支持在View Pager中翻页浏览图片。 PhotoView 是一款扩展自Android ImageView，支持通过单点/多点触摸来进行图片缩放的智能控件。功能实用和强大。 PhotoView 的功能： · 图片浏览查看 · 双指缩放 · 单点触摸缩放 · 图片缩放模式设置 图片缩放库--PhotoView的基本使用_dpl12的博客-CSDN博客 https://blog.csdn.net/dpl12/article/details/78160993 实现点击图片大图浏览 1.自己实现 1.通过 Intent 传送参数到新的 Activity 参考链接 Android仿微信图片点击全屏效果 android 仿微信点击图片放大效果实现 //大图预览 Intent intent = new Intent(HomeActivity.this,PictureDisplayActivity.class); intent.putExtra(&quot;position&quot;,position); intent.putIntegerArrayListExtra(&quot;enlargeImage&quot;, (ArrayList&lt;Integer&gt;) createImageIDData()); intent.putStringArrayListExtra(&quot;enlargeImage&quot;,imgUrl); startActivity(intent); 链接：Android浏览图片，点击放大至全屏效果 我不知道QQ那个是怎么做的，我的思路如下： 首先，从图片缩略界面跳转到图片详情页面，应该是从一个Activity跳转到另外一个Activity，应该图片详情页面也有很多操作，用View或者Dialog不是很好。所以现在难点就是，如何使得前一个界面的ImageView在另外一个界面做缩放切割动画。 一般缩略界面的ImageView的是如上图所示的正方形的，并且是CENTER_CROP缩放属性的。CENTER_CROP属性会导致ImageView中显示的Bitmap有被切割达到填充的效果。 而详情页面的ImageView一般都是FIT_CENTER的缩放属性。所以要保证这个跳转动画的流畅，要做如下的变化： 1、Bitmap的缩放，因为缩略图和详情图的缩放比例肯定不一样 2、Bitmap位置的平移，因为缩略图的位置是不确定的，我们要使他平移到中间 3、Bitmap的切割，因为CENTER_CROP是切割过得，而FIT_CENTER是没有切割的，那么两幅图显示的内容区域是不同的，所以也要显示区域的平滑变换。 要完成上面的效果，如果单单是指对ImageView做一个动画变换，我觉得是完成不了这个要求的。所以自己重写了ImageView来完成上述的变换。 2.dialog——点击图片后创建dialog用dialog承载 展示当前所点击的图片大图 参考链接 安卓图片（ImageView）：展示大图、双击放大、触摸放大缩小、滑动切换、长按保存等——主要就是依赖photoView开源代码 PhotoView+Glide+Dialog+ViewPager:打造轻量级的图片浏览方案 3.缩放 Matrix Android实现图片查看 - 简书 android 图片点击一下就放大到全屏,再点一下就回到原界面 4.ViewPager结合PhotoView Android 使用ViewPager结合PhotoView开源组件实现网络图片在线浏览功能 4.使用第三方图片浏览框架 MNImageBrowser 一个图片浏览框架,支持AndroidX,支持Fresco,类似微信图片浏览,手势向下滑动关闭,图片加载引擎自定义,支持长按,单击监听,切换监听,自定义任意的遮罩层，实现各种效果,支持横竖屏切换,简单方便。 可以自定义使用图片加载引擎（Fresco、Glide、Picasso），效果较好，接近我想要的效果。但是代码说明有点问题，使用有点麻烦好像。内部使用了PhotoView 参考链接 MNImageBrowser图片浏览框架，向下滑动关闭 2.超级强大的第三方库——XPopup（推荐使用） 1.显示内部资源 public void XPopup(int position, BaseQuickAdapter adapter) { // 图片加载器，XPopup不负责加载图片，需要你实现一个图片加载器传给我，这里以Glide为例（可直接复制到项目中）: class ImageLoader implements XPopupImageLoader { @Override public void loadImage(int position, @NonNull Object url, @NonNull ImageView imageView) { //必须指定Target.SIZE_ORIGINAL，否则无法拿到原图，就无法享用天衣无缝的动画 Glide.with(imageView).load(url).apply(new RequestOptions().override(Target.SIZE_ORIGINAL)).into(imageView); } //必须实现这个方法，返回uri对应的缓存文件，可参照下面的实现，内部保存图片会用到。如果你不需要保存图片这个功能，可以返回null。 @Override public File getImageFile(@NonNull Context context, @NonNull Object uri) { try { return Glide.with(context).downloadOnly().load(uri).submit().get(); } catch (Exception e) { e.printStackTrace(); } return null; } } //当你点击图片的时候执行以下代码： // 多图片场景（你有多张图片需要浏览） //srcView参数表示你点击的那个ImageView，动画从它开始，结束时回到它的位置。 new XPopup.Builder(this).asImageViewer((ImageView) adapter.getViewByPosition(position, R.id.Recycler_item_imageView), position, (ArrayList) createImageIDData(), new OnSrcViewUpdateListener() { @Override public void onSrcViewUpdate(ImageViewerPopupView popupView, int position) { // 作用是当Pager切换了图片，需要更新源View popupView.updateSrcView((ImageView) adapter.getViewByPosition(position, R.id.Recycler_item_imageView)); } }, new ImageLoader()) .show(); // // 单张图片场景 // new XPopup.Builder(this) // .asImageViewer(null, createImageIDData().get(position), new ImageLoader()) // .show(); } 2.显示网络图片 5.广播机制 6.数据存储 5.后端连接开发 移动数据库 Realm 是一个移动数据库，可运行于手机、平板和可穿戴设备之上。可以让你的应用更快速，带来难以想象的体验。其目标是为了代替 CoreData 和 SQLite 数据库。 opensource: PostgreSQL,MySQL, Firebird,SQLLite, Berkele,Derby,Db4o other: sybase 7.内容提供器 9.网络技术 Android通过PHP服务器实现登录 Android客户端和PHP、MySQL搭建的服务器之间的简单交互，实现登录功能 。 实现原理图： 9.1WebView控件的用法 作用：用于在app内展示网页。 WebView 已经在后台帮我们处理好了发送HTTP请求、接收服务响应、解析返回数据，以及最终的页面展示这几步工作，不过由于它封装得实在是太好了，反而使得我们不能那么直观地看出HTTP协议到底是如何工作的。因此接下来就让我们通过手动发送HTTP请求的方式，来更加深入地理解一下这个过程。 9.2使用HTTP协议访问网络 工作原理： 客户端向服务器发送一条HTTP请求，服务器收到请求之后会返回一些数据给客服端，最后客户端对数据进行解析和处理。 Http请求工具 Google开发的Volley，loopj的Android Async Http，Square开源的OkHttp或者Retrofit等。 1. 历史上Http请求库优缺点 在讲述OkHttp之前, 我们看下没有OkHttp的时代, 我们是如何完成http请求的. 在没有OkHttp的日子, 我们使用HttpURLConnection或者HttpClient. 那么这两者都有什么优缺点呢? 为什么不在继续使用下去呢? HttpClient是Apache基金会的一个开源网络库, 功能十分强大, API数量众多, 但是正是由于庞大的API数量使得我们很难在不破坏兼容性的情况下对它进行升级和扩展, 所以Android团队在提升和优化HttpClient方面的工作态度并不积极. HttpURLConnection是一种多用途, 轻量极的HTTP客户端, 提供的API比较简单, 可以容易地去使用和扩展. 不过在Android 2.2版本之前, HttpURLConnection一直存在着一些令人厌烦的bug. 比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能： private void disableConnectionReuseIfNecessary() { // 这是一个2.2版本之前的bug if (Integer.parseInt(Build.VERSION.SDK) &lt; Build.VERSION_CODES.FROYO) { System.setProperty(&quot;http.keepAlive&quot;, &quot;false&quot;); } } 因此, 一般的推荐是在2.2之前, 使用HttpClient, 因为其bug较少. 在2.2之后, 推荐使用HttpURLConnection, 因为API简单, 体积小, 并且有压缩和缓存机制, 并且Android团队后续会继续优化HttpURLConnection. 但是, 上面两个类库和OkHttp比起来就弱爆了, 因为OkHttp不仅具有高效的请求效率, 并且提供了很多开箱即用的网络疑难杂症解决方案. - 支持HTTP/2, HTTP/2通过使用多路复用技术在一个单独的TCP连接上支持并发, 通过在一个连接上一次性发送多个请求来发送或接收数据 - 如果HTTP/2不可用, 连接池复用技术也可以极大减少延时 - 支持GZIP, 可以压缩下载体积 - 响应缓存可以直接避免重复请求 - 会从很多常用的连接问题中自动恢复 - 如果您的服务器配置了多个IP地址, 当第一个IP连接失败的时候, OkHttp会自动尝试下一个IP - OkHttp还处理了代理服务器问题和SSL握手失败问题 使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。 还有一个好消息, 从Android 4.4起, 其HttpURLConnection的内部实现已经变为OkHttp, 您可以参考这两个网页:爆栈网和Twitter. 1.原生网络通信库HttpURLConnection 2.开源的受欢迎的网络请求框架OkHttp——OkHttp使用完全教程（￥超级推荐看这个） 由Square公司开发，该公司还开发了Picasso、Retrofit 教程：https://www.jianshu.com/p/9aa969dd1b4d https://blog.csdn.net/u013651026/article/details/79738059 Get a URL This program downloads a URL and prints its contents as a string. Full source. OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } Post to a Server This program posts data to a service. Full source. public static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody body = RequestBody.create(json, JSON); Request request = new Request.Builder() .url(url) .post(body) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } Further examples are on the OkHttp Recipes page. 1.使用 创建一个OkHttpClient实例 OkHttpClient client = new OkHttpClient(); 创建Request对象 String url=&quot;https://gank.io/api/v2/categories/Girl&quot;; Request request = new Request.Builder() .url(url) .build(); 9.3解析XML格式数据 Pull解析 SAX解析 DOM解析（可以不用理解） 9.4 ￥解析JSON格式数据（推荐） JSON相比于XML优势在于体积小，更省流量。缺点：语义性较差，不如XML直观。 1.官方提供的JSONObject 2.GSON（推荐） Gson是谷歌官方推出的支持 JSON -- Java Object 相互转换的 Java序列化/反序列化 库 Retrofit 1.Retrofit2的简述 Retrofit其实我们可以理解为OkHttp的加强版，它也是一个网络加载框架。 底层是使用OKHttp封装的。准确来说,网络请求的工作本质上是OkHttp完成， 而 Retrofit 仅负责网络请求接口的封装。它的一个特点是包含了特别多注解， 方便简化你的代码量。并且还支持很多的开源库(著名例子：Retrofit + RxJava)。 Retrofit和OkHttp都是square公司写的. 10.服务 10.1 服务 10.2 多线程编程 RxJava AsyncTask 和Handler 10.3 服务的基本用法 10.4 服务的生命周期 10.5 11.依赖库 依赖库： 注解框架 butterknife Json解析 Gson 解析Html jsoup 网络框架 retrofit okhttp 打印日志框架 klog 图片加载 glide 刷新框架 SwipeToLoadLayout 权限管理库 AndPermission 提示框 material-dialogs Android-SVProgressHUD RecycleView分割线 RecyclerView-FlexibleDivider ViewPager的标题控件 smarttablayout 广告轮播控件 SwitcherView 收藏按钮 ThumbUp 模糊控件 Blurry 网络请求监控 chuck 表格控件 scrollablepanel 可以展开的文字 expandableTextView 自定义日历控件 MNCalendar 日志监听 MNCrashMonitor 图片缩放 PhotoView APK升级安装 MNUpdateAPK 夜间模式 MNChangeSkin 图片浏览 MNImageBrowser 汉字转拼音 TinyPinyin 快速跳跃分组的侧边栏控件 WaveSideBar 背景可以移动的View KenBurnsView 圆形图片 CircleImageView 滚轮选择器 Android-PickerView 图片选择器 PictureSelector 吐血整理，Android常用库和插件，避免重复造轮子 干货集中营（gank.io）福利图 技术栈：RecyclerView + Glide + OkHttp + Gson + Retrofit 开发环境： Windows 10 + Android Studio 2.3.2 兼容 Android 4.0 ~ 7.0 主界面展示妹子缩略图列表，下拉刷新，上拉加载更多， 点击图片可以查看大图，长按大图可以保存到本地。文件管理器打开存储，在Pictures/GankBeauty目录里面。 使用Glide保存图片，代码中有两种方式，其中使用bitmap的方式会造成图片比在电脑让下载的原图体积变大，而使用downloadOnly的方式实现的，保存的图片大小与从电脑上下载的图片对比，大小一致，md5也一致。因此bitmap方式的代码注释掉了，推荐使用downloadOnly的方式 12.Material Design（质感设计）（Android5.0以后） Toolbar RippleDrawable涟漪效果_水波纹/涟漪——触摸反馈 ​ 涟漪效果是Android5.0以后的新特性，只有api&gt;=21才能使用ripple效果。为了兼容性，建议新建drawable-v21文件夹来存放RippleDrawable，drawable文件夹下也要放相应的适配图片。（这里可以安装一个AndroidSelector插件，具体的可以参考https://blog.csdn.net/oqihaogongyuan/article/details/53102615的第三部分） 涟漪动画主要是对于ripple标签的使用。，其中ripple节点的，必须要设置color属性。这里根节点的设置的color就是涟漪效果的波纹颜色。子节点的item设置的drawable是涟漪效果的背景（也可以认为是涟漪效果的展示范围）。 ​ Android中Button控件是有点击效果的，但是像TextView、ImageView、各种Layout是没有点击效果的，给TextView设置点击事件后，加个点击效果用户触控反馈会好一点； 第一种：Material自带水波纹（最简单的默认点击效果） 通过如下代码设置波纹的背景： android:background=&quot;?android:attr/selectableItemBackground&quot;波纹有边界 android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;波纹超出边界 //android:clickable=&quot;true&quot; //android:focusable=&quot;true&quot; 如果该空间已经有背景色了，可以设置前景色 android:foreground=&quot;?android:attr/selectableItemBackground&quot; 为view添加波纹效果： &lt;RelativeLayout android:id=&quot;@+id/user_info_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:clickable=&quot;true&quot; android:background=&quot;?android:attr/selectableItemBackground&quot; &gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerInParent=&quot;true&quot; android:contentDescription=&quot;@null&quot; android:paddingRight=&quot;15dip&quot; /&gt; &lt;/RelativeLayout&gt; 注意： 如果设置后点击没有效果 ， 请看一下是否给该控件设置了点击事件 、 并 android:clickable=&quot;true&quot; 前景色：foreground属性只能给控件和帧布局设置，其它的布局设置无效果，具体看Android源码； 或者有兼容低版本的同资源也要修改添加效果。 第二种方法 2.1 添加一个普通的 ripple_bg_drawable.xml 背景文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#8cc476&quot; /&gt; &lt;corners android:radius=&quot;0dp&quot; /&gt; &lt;/shape&gt; 2.2添加带波纹效果的背景文件 ripple_bg.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;#FF21272B&quot;&gt; &lt;item android:drawable=&quot;@drawable/ripple_bg_drawable&quot; /&gt; &lt;/ripple&gt; CardView（卡片式布局） ​ CardView是Android5.0之后新增的卡片式控件，以往，我们需要自定义Shape来实现圆角和阴影效果；现在，这些效果集成到了CardView的属性里。 实际上，CardView也可以看做是一个FrameLayout，继承自FrameLayout，方便作为其他控件容器，提供了圆角和阴影等效果，看上去有立体的感觉。 13.点击事件 1.屏幕单点/多点触控 设置单点触控splitMotionEvents 一、全局单点触控，在application引用的Theme主题中添加以下内容，整个应用只能单点触控： &lt;item name=&quot;android:splitMotionEvents&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:splitMotionEvents&quot;&gt;false&lt;/item&gt; 二、某个界面需要单点触控的话，直接在需屏蔽布局的父布局xml文件中设置： android:splitMotionEvents=&quot;false&quot; 多点触控问题解决(windowEnableSplitTouch, splitMotionEvents) 2.屏幕点击事件理解（抽象类及其继承理解理解)——防止recyclerview item重复点击 抽象类如果通过匿名内部实例化 ，则抽象类中的抽象方法必须被重载，抽象类中的其他普通方法则也必须会被实现 2020.11.21的recyclerview的防止重复点击有助于理解。 1.重写OnItemClickListener ，构造抽象类 OnNoDoubleClickListener 实现 OnItemClickListener public abstract class OnNoDoubleClickListener implements OnItemClickListener { // 0.9秒内防止多次点击 public static final int MIN_CLICK_DELAY_TIME = 900; private long lastClickTime = 0; public void onItemClick(@NonNull BaseQuickAdapter&lt;?, ?&gt; adapter, @NonNull View view, int position) { long currentTime = Calendar.getInstance().getTimeInMillis(); if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) { lastClickTime = currentTime; onNoDoubleClick(adapter, view, position); } } // 用户需要进一步实现 protected abstract void onNoDoubleClick(@NonNull BaseQuickAdapter&lt;?, ?&gt; adapter, @NonNull View view, int position); } public interface OnItemClickListener { /** * Callback method to be invoked when an item in this RecyclerView has * been clicked. * * @param adapter the adapter * @param view The itemView within the RecyclerView that was clicked (this * will be a view provided by the adapter) * @param position The position of the view in the adapter. */ void onItemClick(@NonNull BaseQuickAdapter&lt;?,?&gt; adapter, @NonNull View view, int position); } 2.点击实现（理解时注意看一下代码区别） //条目点击事件 adapter.setOnItemClickListener(new OnNoDoubleClickListener() { @Override public void onNoDoubleClick(BaseQuickAdapter adapter, View view, int position) { Log.d(TAG, &quot;onItemClick: &quot;); Toast.makeText(HomeActivity.this, &quot;点击了第&quot; + (position + 1) + &quot;条条目&quot;, Toast.LENGTH_SHORT).show(); XPopup(position, adapter); } }); //条目长按事件 adapter.setOnItemLongClickListener(new OnItemLongClickListener() { @Override public boolean onItemLongClick(BaseQuickAdapter adapter, View view, int position) { Log.d(TAG, &quot;onItemLongClick: &quot;); adapter.remove(position); Toast.makeText(HomeActivity.this, &quot;长按了第&quot; + (position + 1) + &quot;条条目&quot;, Toast.LENGTH_SHORT).show(); return false; } }); } gradle命令——gradlew（打包签名等） android studio gradle 命令行 在windows的cmd窗口或者powershell窗口可以使用gradlew命令，但是要在前面加上 .\\gradlew 或者在Android Studio的Terminal上输入，但是要在前面加上 gradlew gradlew tasks 显示可用的命令 Install tasks installDebug - Installs the Debug build. installDebugAndroidTest - Installs the android (on device) tests for the Debug build. uninstallAll - Uninstall all applications. uninstallDebug - Uninstalls the Debug build. uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build. uninstallRelease - Uninstalls the Release build. 安装任务 ------------- installDebug—安装调试版本。 installDebugAndroidTest——为调试版本安装android(在设备上)测试。 卸载-卸载所有应用程序。 uninstallDebug—卸载调试版本。 uninstallDebugAndroidTest -卸载调试版本的android(在设备上)测试。 uninstallRelease——卸载发布版本。 Build tasks assemble - Assemble main outputs for all the variants. assembleAndroidTest - Assembles all the Test applications. build - Assembles and tests this project. buildDependents - Assembles and tests this project and all projects that depend on it. buildNeeded - Assembles and tests this project and all projects it depends on. bundle - Assemble bundles for all the variants. clean - Deletes the build directory. cleanBuildCache - Deletes the build cache directory. compileDebugAndroidTestSources compileDebugSources compileDebugUnitTestSources compileReleaseSources compileReleaseUnitTestSources 1、gradlew -v 查看当前项目所用的Gradle版本 2、gradlew clean 清除9GAG/app目录下的build文件夹 3、gradlew build 编译项目并生成相应的apk文件 4、gradlew assembleDebug 编译并打Debug包 5、gradlew assembleRelease 编译并打Release的包 6、gradlew installRelease Release 模式打包并安装 7、gradlew uninstallRelease 卸载Release模式包 使用gradlew命令行，更加容易操作，而且容易找出error，还可以更新或者下载配置好编译环境，如gradle的版本更新之类 Context Android Studio快捷键 注释代码 选中一行或几行代码，按“Ctrl + Shift+/”可以给将代码块注释在“/”和“/”中。 再次按“Ctrl + Shift+/”可以取消注释。 批量替换 Shift+F6 插件的使用 1.ButterKnife插件使用 注解框架 butterknife 1.在项目的bulid.gradle中添加依赖，如下图所示： classpath 'com.jakewharton:butterknife-gradle-plugin:10.2.3' //butterknife插件,加入对应最新版本 在APP的bulid.gradle中添加依赖： dependencies { //ButterKnife插件使用 implementation 'com.jakewharton:butterknife:10.2.3' annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3' } 3.在 Activity 的 onCreate 方法中间 加入 ButterKnife.bind(this); protected void onCreate(Bundle savedInstanceState) { Bmob.initialize(this, &quot;d26004a40bcb7e3f58360c2a17332282&quot;); super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); ButterKnife.bind(this); } 2.simpleUML 生成的UML图默认只有聚合类型的线条，可选中一个类图右键-Add某种关系，或者右键-Dependencies添加全部关系。 或者Alt+A全部选中，执行上述操作。左边有两栏操作按钮，都很简单：导入UML图、导出UML图、俯瞰图。 共有六中关系，从上到下依次为：泛化（继承）、实现、聚合、内部类、依赖、组合。再往下就是自动排列图形。 关于导出UML图，有六种格式可选择：BMP、GIF、JPEG、JPG、PNG、WBMP。缩放比例最大可调至400。关于六种格式，简单介绍下： BMP:Bitmap（位图格式），不压缩，容量大。在window环境最不容易出问题，使用广泛，适合单机使用。 GIF:失真有损压缩格式。压缩时保证像素资料，丢失色彩资料。广泛应用。 JPEG:有损高压缩的图像压缩格式。部分细节会被删除，不适合放大看。原图大小情况下，肉眼看没差边。 PNG:为WEB图像订制的格式。与GIF相似，但色彩数要多很多。 注释规约（阿里巴巴） 如何从github下载项目的源代码，包含git客户端，直接下载，vs下载 1.直接下载： 点击Download ZIP按钮，即可以实现下载源代码，解压，即可。这种方式比较简单直接，不需要你的电脑安装其他东西。 2.使用git 1.GIT GUI here 2.使用git命令（GIT Bash here）从github上clone项目 首先创建本地仓库（实际上就是创建一个文件夹，放项目代码），然后cd进文件夹， 初始化空的git仓库 注意：这里不初始化也是可以clone的 然后git clone url（url表示项目网址） 然后就可以了，如果中途中断clone，文件夹不会显示任何文件。 3.GitHub Desktop下载:https://desktop.github.com/ 4.软件内自带VCS下载 Android Studio使用 不用急着更新新版本，以后晚一点更新Android Studio，等插件都更新了才好 挺好用的快捷键 1.打开Project Structure（Ctrl+Alt+Shift+S） 用于管理添加依赖 2.快速收起/打开代码 windows下 ctrl+shift+（小键盘上的减号 -） ctrl+shift+（小键盘上的减号 +） 3.Gradle下载慢或者失败 查看gradle版本方法： 1.打开gradle-wrapper.properties 中的最后一行就是gradle版本 2.ctrl+alt+shift+s打开项目结构 下载网址https://services.gradle.org/distributions/ 找到对应的版本进行下载 我的gradle地址为 C:\\Users\\Sage.gradle\\wrapper\\dists\\gradle-6.5-bin.zip 将下载后的gradle版本和之前的gradle进行替换之后 手动修改gradle-wrapper.properties中的gradle路径问本地路径： 重启AndroidStdio就OK了 4.类结构查看工具Structure详解 1.Java类的基本组成内容信息图形表示 TextView一个方法的表示 structure小符号意义 1.C——class 2.f——fields 字段，属性，域，变量 3.m——meth member function成员函数 4.I——interface接口 public private TextView的类结构信息如下图(筛选全选) 1.Java类的基本组成内容信息图形表示 TextView一个方法的表示 TextView一个字段的表示 2.所有图标的分类详解 2.1.类基本组成内容 类型 图标 示例 类-Class-C public class TextView extends View 接口-interface-I public interface OnEditorActionListener 注解-annotation-@ public @interface AutoSizeTextType 枚举-enum-E public enum BufferType 方法-Method-m public TextView(Context context) 字段-Field-f private CharSequence mText; 2.2.修饰符 类型 图标 示例 static static long sLastCutCopyOrTextChangedTime; final private final TextPaint mTextPaint; 2.3.访问权限 类型 图标 示例 公共-public public boolean onDragEvent(DragEvent event) 保护-protected @Override protected void onAttachedToWindow() 默认(包访问)-default int mCursorDrawableRes; 私有-private private CharSequence mText; 2.4继承 类型 图标 示例 实现-implements @Override 被实现-implemented 3.工具栏筛选选项详解 当所有的筛选选项都不选择时，类信息的排序默认是按照在文件中的顺序进行排列，默认不显示字段内容，并且只显示public权限的内容。 工具栏筛选都不选的情况下TextView显示信息 3.1 按访问权限排序 sort by visibility 按照对外可见性的权限大小进行排序，public-&gt;protect-&gt;default-&gt;private 3.2 按字母表顺序进行排序 Sort Alphabetically 按照字母表A-&gt;Z的顺序大小进行排序，选中后，Textview结构图示例如下 可以看到排列顺序是分不同组别的，非方法与非字段的其它内容一组，方法一组，字段一组,同组之间的内容排序才是按照字母表顺序进行的。 3.3 方法的覆盖或实现分组 Group Methods by Defining type 选中后，将会把类中实现的接口或者覆盖的父类方法放在同一个组中，便于查阅。 3.4 bean类属性的分组 Show Propertied 选中后，会将类中的所有bean属性变量单独分组，带有getter或者setter方法。如下图 3.5 显示字段(默认不显示) Show Fields 3.6 显示非公有内容 Show no-Public 选中后，会将所有的非公有内容都显示出来，包括内部类，字段，方法等。 3.7 显示继承的内容 Show Inherited 选中后会将父类所拥有的属性或者方法(主要是public,protected权限)都显示出来 inherited——继承 3.8 显示匿名类 Show anonymous Classes 3.9 显示lambdas表达式 Show lambdas 3.10 全部展开与全部折叠 展开expand all 展开collapse all 3.11 自动定位 左侧选择方法等内容右侧源码自动定位 AutoScroll to source 右侧选择源码左侧内容自动定位 AutoScroll from source 5.何快速抽离出一个方法 6.Alt+Enter 显示提示框 7.快速输入for循环 fori 或者 输入for，Alt+Shift+Enter 8.快捷键Ctrl+O查看需要重写的方法 APK文件压缩 一般说来，classes.dex, 它包含了我们所写的Java代码经过编译后class文件；resources.arsc 包含了预编译之后的资源文件（比如values文件，XML drawables 文件等。）。 解决混淆压缩出现“Cannot fit requested classes in a single dex file”的问题 问题描述 编译时出现Cannot fit requested classes in a single dex file (# methods: 73436 &gt; 65536)的问题。 原因：项目貌似有点大，已经超过65k个方法。一个dex已经装不下了，需要个多个dex，也就是multidex ，因为Android系统定义总方法数是一个short int，short int 最大值为65536。 问题解决 1.Entry name 'res/color/material_on_surface_disabled.xml' collided 点build，clean project清除一下缓存就好了 2.gradle命令错误——Error:Unable to start the daemon process. This problem might be caused by incorrect configuration of 找到工程文件下的gradle.properties文件，修改其中 org.gradle.jvmargs s的值 org.gradle.jvmargs=-Xmx1024m 3解决 fatal: Not a git repository (or any of the parent directories): .git 问题 git init 4.恢复删除的文件，撤回操作 项目名右键——Local History——Show History 5.远程主机强迫关闭了一个现有的连接(adb.exe已停止工作) adb.exe的端口被占用了。 可以先试试用adb kill-server 和 adb start-server试试能不能解决，如果不能解决 1、开始-运行-cmd 或者 Android Studio下的 terminal 打开终端窗口。输入 netstat -aon|findstr &quot;5037&quot; 查看5037端口都有哪些进程，如下图： 2、然后在根据其PID进程号来找出该进程（上图中的最后一行）。 如上图可以发现5037端口被PID为5884的进程占用，输入 tasklist|findstr &quot;2748&quot; ，找出该进程，如下图： 3、这里studio64.exe是正常的，如果你的是其他进程的话，就要结束它了（taskkill /f /pid 459616）。 上述无法解决，执行以下cmd命令 3.adb nodaemon server 6.连续点击出现多个Activity界面 复习一下activity的[启动模式](# 8.活动的启动模式)。 前言 开始始学习android，对android的启动模式没有什么了解，就使用了时间判断是否重复点击了两次按钮，启动另外的activity界面，这样的控制方法，有时候会失效，比如，两秒钟还未启动另外的activity，那么又可以重复点击。所以，就调整为android的启动模式来控制重复出现多个acitvity。 一、通过时间控制点击次数： 这种方式对应控制网络请求不错。 public class NoDoubleClickUtil { private static long lastClickTime; private final static int SPACE_TIME =2000; public static void initLastClickTime() { lastClickTime = 0; } public synchronized static boolean isDoubleClick() { long currentTime = System.currentTimeMillis(); boolean isClickDouble; if (currentTime - lastClickTime &gt; SPACE_TIME) { isClickDouble = false; } else { isClickDouble = true; } lastClickTime = currentTime; return isClickDouble; } }123456789101112131415161718192021 二、通过launchMode启动模式控制出现多个activity的方式： 这种方式真正意义上杜绝了同时出现相同的多个activity。 &lt;activity android:name=&quot;.InternetHospital.InternetHospitalInquiryCallUI&quot; android:launchMode=&quot;singleInstance&quot;/&gt;12 或者在代码中设置： Intent intent = new Intent(); intent.setClass(getApplicationContext(), TargetActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent);1234 三、android的四种启动模式： 1、standard模式：每次调用startActivity()启动时都会创建一个新的Activity放在栈顶（默认都是这个模式） 2、singleTop模式：启动Activity时，指定Activity不在栈顶就创建，如在栈顶，则不再创建（不会出现两个相同的Activity相邻） 3、singleTask模式：如果启动的Activity不存在就创建Activity，如果存在直接跳转到指定的Activity所在位置（在其上面的Activity会被移出栈,也就是一个栈中不能有重复的Activity） 4、singleInstance模式：如果启动的Activity不存在就创建一个Activity同时创建一个栈，如果存在就将指定的Activity存在的栈移动到栈顶（表示这个Activity只能存在于一个独立的任务栈中,同应用的其它Activity与其无关） recyclerview可以通过xml文件中添加 android:splitMotionEvents=&quot;false&quot; 属性 android:splitMotionEvents：定义布局是否传递触摸事件（touch）到子布局，true表示传递给子布局，false表示不传递。 例如：在你的Activity页面中有一个ImageView控件，这时你做一个滑动屏幕跳转页面和滑动ImageView切换图片，如果你将android:splitMotionEvents设置为false，你的切换图片功能将会无法实现，因为图片属于子布局，且他接收不到父布局传递过来的触摸事件。 7.[recyclerview重复点击问题](#1.重写OnItemClickListener ，构造抽象类 OnNoDoubleClickListener 实现 OnItemClickListener) 1.重写点击事件 ——封装一个点击事件，处理点击间隔判断 缺点：相比于第2种方式，这种方法将重复点击的判断封装在CustomClickListener内部，外部无需处理时间判断，只需要实现点击方法即可。 2.利用系统时间差——每个按钮点击事件中，记录点击时间，判断是否超过点击时间间隔 缺点：这种方式，每个点击事件都需要写一个时间判断，重复代码很多。 //全局定义 private long lastClickTime = 0L; // 两次点击间隔不能少于1000ms private static final int FAST_CLICK_DELAY_TIME = 1000; //在设置Item的监听时 item.setOnItemClickListener(xxx){ if (System.currentTimeMillis() - lastClickTime &gt;= FAST_CLICK_DELAY_TIME) { //下面进行其他操作，比如跳转等 XXX lastClickTime = System.currentTimeMillis(); } } 3.￥￥工具类，用于判断是否快速点击（现在想想这个好像会简单点） 该方法与方法 2 的原理类似： // 两次点击间隔不能少于1000ms private static final int FAST_CLICK_DELAY_TIME = 1000; private static long lastClickTime; public static boolean isFastClick() { boolean flag = true; long currentClickTime = System.currentTimeMillis(); if ((currentClickTime - lastClickTime) &gt;= FAST_CLICK_DELAY_TIME ) { flag = false; } lastClickTime = currentClickTime; return flag; } btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (Utils.isFastClick()) { // 进行点击事件后的逻辑操作 } } }); 4.使用 RxJava 的 throttleFirst() 响应式地处理按钮点击，利用rxjava的操作符，来防止重复点击，相较于第1,2方案来说，此方法更为优雅一些。 思考一下： 这三种方法，不论哪一种，都对原有点击事件有很大的侵入性，要么你需要往Click事件中加方法，要么你需要替换整个Click事件，那么，有没有一种方式，可以在不改动原有逻辑的情况下，又能很好地处理按钮的重复点击呢？ 5.引入AOP 8.Raw use of parameterized class 'xxxx' 警告 意思：“参数化类的原始使用” 泛型不要使用原生态类型 会导致 丢失类型安全性 解决方法 意思是这个类要使用泛型 在类后面加上，&lt;&gt; 对应泛型 例如 FilterRegistrationBean FilterRegistrationBean&lt;HeaderFilter&gt; // HeaderFilter 自定义的过滤器 为什么会出现这个警告？ 因为 FilterRegistrationBean 是一个泛型类 FilterRegistrationBean&lt;T extends Filter&gt; 9.'remove(int)' is deprecated(过时) adapter.remove(position); 尝试了以下这种解决方法，但事实上根本不行 adapter.removeAt(position); adapter.notifyDataSetChanged(); 仍待解决？ 待解决 点击放大了，但是感觉圆角效果还是待改善 RippleDrawable涟漪效果了解了一些，会了一点点，但是RecyclerView中的图片点击效果还有一点不够完善。——继续学习 触发事件功能还要继续琢磨 多版本xml文件理解 context理解 ","link":"https://SageRover.github.io/post/android/"},{"title":"Success","content":"simple和paper主题不错。simple细节稍差。 好看的有：clean，paper，pure，nederburg ","link":"https://SageRover.github.io/post/success/"},{"title":"程序员基础","content":"字符编码问题 一旦走上了编程之路，如果你不把编码问题搞清楚，那么他将像幽灵一样纠缠你的整个职业生涯，各种灵异事件接踵而至，挥之不去。只有充分发挥程序员死磕到底的精神，你猜有可能彻底摆脱编码问题带来的烦恼。 ASCII 占1个字节，只支持英文 ANSI GB2312 占2个字节，支持6700+中文 GBK GB2312的升级版，支持21000+汉字 shift-JIS 日本字符 ks_c_5601-1987 韩国编码 TIS-620 泰国编码 unicode UTF-8 由于每个国家都有自己的字符，所以其对应关系也涵盖了自己国家的字符，但是以上编码都存在局限性，应运而生，出现了万国码，它涵盖了全球所有的文字和二进制的对应关系。 unicode 2-4字节，已经收录136690个字符，并还在一致不断扩张中... unicode解决了字符和二进制的对应关系，但是使用unicode表示一个字符，太浪费空间，例如：利用unicode表示&quot;Python&quot;需要12个字节，比原来的ASCII增加了一倍！ 为了解决存储和网络传输的问题，出现了Unicode Transformation Format ,学术名：UTF。 UTF-8 :使用1,2,3,4个字节表示所有字符，优先使用1个字符，无法满足则增加一个字节，最多4个 【英文占1个，欧洲语系占2个，东亚占3个，其他及特殊字符占4个】 UTF-16 :使用2,4个字节表示所有字符，优先使用2个字节，否则使用4个。 UTF-32 :使用4个字节表示所有字符。 总结：UTF是为unicode编码涉及的一种在存储和传输时节省空间的编码方案。 字符在硬盘上的存储： 无论以什么编码在内存里显示字符，存到硬盘上都是二进制。要注意的是，存到硬盘上时是以何种编码存的，再从硬盘上读取出来时，就必须以何种编码读。 虽然国际语言是英语，但是大家在自己的国家依然说自己的语言，不过出了国，你就得学会英语，编码也一样，虽然有了UTF-8，但是由于历史原因，各个国家依然在大量使用自己的编码， 比如中国的Windows，默认编码依然是GBK，而不是UTF-8 编码转换过程： 实际代码演练中，在py3上，把你的代码以utf-8编写，保存，然后再Windows上执行。 so一切都很美好，到这里，我们关于编码的学习按说就可以结束了。 但是，如生活一样，美好的表面下，总是隐藏着不进入人意，上面的UTF-8编码之所以能在Windows GBK的终端下显示正常，是因为到了内存里python解释器吧utf-8转成了unicode，单这只是Python3，并不是所有的编程语言在内存里默认编码都是unicode，比如万恶的Python2就不是，他的默认编码是ASCII，想写中文就必须声明文件头的coding为gbk或者UTF-8，声明之后，python2解释器仅以文件头生命的编码去解释你的代码，加载到内存后，并不会主动帮你转成Unicode，也就是说你的文件编码是UTF-8加载到内存里，你的变量字符串就也是UTF-8，这意味着什么你知道吗？ 意味着你以UTF-8编码的文件，在Windows是乱码。 乱是正常的，不乱才不正常，因为只有两种情况，你的Windows上显示才不会乱。 1.字符串以GBK格式显示 2.字符串是unicode编码 既然Python2并不会自动的把文件编码转换为unicode存在内存里，那就只能使出最后一招了，你自己人肉转。Py3自动把文件编码转为unicode必定是调用了什么方法，这个方法就是，decode(解码) 和encode(编码)。 UTF-8 ---&gt; decode解码 ---&gt; Unicode Unicode ---&gt; encode编码---&gt;GBK/UTF-8 decode实例： encode实例： 记住下图规则： 一般UTF-8一个中文占三个字节，GBK一个占2个字节。 Python bytes类型 在python2上写字符串。 虽说打印的是路飞，但是直接调用变量s.看到的却是一个个的16进制表示的二进制字节，我们怎么称呼这样的数据呢？直接叫二进制么？也可以，但相比于010101，这个数据穿在表示形式上又把2进制转成了16进制来表示，这是为什么呢？哈，为的就是让人们看起来更可读，我们称之为bytes类型，即字节类型，他把8个二进制一组称为一个byte,用16进制来表示。 想告诉你一个事实，Python2里面bytes == str，其实这是一回事，除此之外，python2里面还有个单独的类型是unicode，把字符串解码后，就会变成unicode。 python的发展越来越快，已经不能再修修补补。Python3横空出世， python3除了把字符串的编码改成了unicode，还把str和bytes做了明确的区分，str就是unicode格式的字符，bytes就是单纯的二进制了。 python只要出现了各种编码问题，无非是哪里的编码设置错了。 常见编码错误的原因： Python解释器的默认编码 Python源文件编码 Terminal使用的编码 操作系统的语言设置，掌握了编码之前的关系后，挨个排错就好了。 vmware-hostd.exe 占用443端口导致某些应用加速无法正常启动？ 如果我们的电脑既安装了VMware虚拟机软件，又安装了XAMPP，启动XAMPP的时候，经常会报错。 提示信息说明： 443号端口被vmware-hostd.exe进程占用了，导致Apache无法启动。 这是因为vmware-hostd.exe默认是使用443号端口的，而它又是默认自动启动的。 我们知道，Apache 的 httpd 服务默认是使用80端口的，而 httpd-ssl 默认是使用443端口的。这就导致了443号端口的冲突。 一般来说，解决方法有两种： 修改 httpd-ssl.conf 配置文件，将443端口改为其他空闲的端口（如4430）。 将 vmware-hostd.exe 的自动启动改为手动启动并将其停止。在桌面的计算机图标点击鼠标右键，选择 “管理→服务和应用程序→服务”，将显示名称为“VMware Workstation Server”的服务的启动类型改为手动，并停止该服务即可。 说明： 上面两种方法中的任何一种都可以。第二种方法一般也不会影响VMware的正常使用。VMware Workstation Server 服务的描述信息为“Remote access service for registration and management of virtual machines.”，也就是说它与远程管理VMware有关。而我们一般也不会使用到VMvare的远程访问功能，所以第二种方法基本没有影响。 ","link":"https://SageRover.github.io/post/cheng-xu-yuan-ji-chu/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://SageRover.github.io/post/hello-gridea/"}]}